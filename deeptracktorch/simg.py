# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_GenerateSyntheticImages.ipynb (unless otherwise specified).

__all__ = ['background', 'radial_grid', 'particle_bessel_response', 'add_noise', 'generate_particles', 'define_image',
           'generate_image', 'add_target', 'generate_mask', 'annotate_image', 'save_img', 'generate_images']

# Cell
from typing import Tuple
import numpy as np
from PIL import Image as PILImage
from deeptrack.disp import *
from numpy.random import choice, normal, uniform, randint
from numpy import pi
import pandas as pd
import matplotlib.pyplot as plt

# Cell
def background(image_size: int, level: float=0, grad_i: float=0, grad_d: float=0) -> np.array:
    """
    Return array representing image background of size `image_size`.
    The image may have an illimination gradient of intensity `I` and direction `grad_d`.
    The `image_size` is in pixels. `grad_i` expected to be between 0 and 1.
    `grad_d` is gradient direction in radians.
    """
    h = image_size // 2
    background = np.ones((image_size,image_size)) * level
    ix,iy = np.meshgrid(np.arange(-h, h + 1), np.arange(-h, h + 1))
    illumination_gradient = grad_i * ((ix * np.sin(grad_d)) + (iy * np.cos(grad_d))) / (np.sqrt(2) * image_size)
    return background + illumination_gradient

# Cell
def radial_grid(S, p:Tuple[float,float], p_r:float, elip_d:float=0, ellipticity:float=1):
    """
    Returns array of size (`S` x `S`) where each value in the array
    is the radial distance  from that pixel to the particle at position `p`.

    """

    # This is in the source code but not in the paper
    MYSTERY_CONST = 1e-6

    h=S//2

    # particle position in pixels relative to centre of image
    icx = h + p[0]*h
    icy = h + p[1]*h

    # calculate radial distance for each pixel to particle centre
    imxs, imys = np.meshgrid( np.arange( 0, S), np.arange( 0, S))

    cs = np.cos(elip_d)
    sn = np.sin(elip_d)
    cx = (imxs - icx)
    cy = (imys - icy)

    rotated_distance_x = (cx * cs + cy * sn)**2
    rotated_distance_y = ((-cx * sn + cy * cs) / ellipticity)**2

    return (np.sqrt( rotated_distance_x + rotated_distance_y + MYSTERY_CONST ) / p_r)


# Cell
from scipy.special import jv as bessel
from torch import Tensor

# Cell
def particle_bessel_response(S:int, p:Tuple[float,float], p_r:float, orders:list, intensities:list, elip_d:float=0, ellipticity:float=1):
    """
    Returns square array of size `S` containing response to particle a `p`
    """
    r=radial_grid(S, p, p_r=p_r, elip_d=elip_d, ellipticity=ellipticity)
    if type(intensities) is Tensor:
        response = torch.zeros_like(r)
    else:
        response = np.zeros_like(r)

    for I,o in zip(intensities,orders):
        if type(I) is Tensor: I=I.numpy()
        response+=(I * 4 * o**2.5 * (bessel(o,r) / r)**2)
    return response


# Cell
def add_noise(img_without_noise, snr):
    """Return `img_without_noise` after adding Poisson noise to to give desired SNR"""

    # where did these come from?
    flr=img_without_noise[:].min()
    img_without_noise-=flr

    img_with_noise = np.random.poisson(np.clip(img_without_noise, 0, 1) * snr**2) / snr**2
    return img_with_noise

# Cell
def generate_particles(p_dist, n, hs):
    p = pd.DataFrame({k:v(n) for (k,v) in p_dist.items()})
    p['cx']=p.x.apply(lambda v: hs+(hs*v))
    p['cy']=p.y.apply(lambda v: hs+(hs*v))
    return p.to_dict(orient='records')

def define_image(img_dist, p_dist, N=1):
    """A helper function to create an image from the image and particle parameters
    returns Dataframe with specification per row
    n: is the number of images"""
    out_df = pd.DataFrame({k:v(N) for (k,v) in img_dist.items()})
    hs = out_df['size'].iloc[0]//2
    out_df['particles'] =  out_df.n_particles.apply(lambda n: generate_particles(p_dist, n, hs))
    return out_df


# Cell
def generate_image(p):
    """Returns a synthetic microscopy image using the parameters defined by `define_image()`
    The parameters `p` can be a `dict` or a row from a DataFrame containing the parameters.
    """

    composed_image = background(int(p['size']), p['bkgd_level'], p['gradient_intensity'], p['gradient_direction'])
    for P in p['particles']:
        pres=particle_bessel_response( int(p['size']),
                                (P['x'],P['y']),
                                p_r=P['radius'],
                               intensities=P['intensities'],
                               orders=P['bessel_orders'],
                               elip_d=P['ellip_direction'],
                               ellipticity=P['ellipticity']
                              )
        composed_image+=pres

    noisy_image = add_noise(composed_image, p['snr'])
    return noisy_image

# Cell
def add_target(specs_df, mode='radius'):
    targets = []
    for img_counter, img_spec in specs_df.iterrows():

        if len(img_spec['particles']) == 0:
            specs_df.loc[img_counter,'tx']=0
            specs_df.loc[img_counter,'ty']=0
            specs_df.loc[img_counter,'tr']=-1

        else:
            particles=pd.DataFrame(img_spec['particles'])
            # sort the particles by closest to the centre

            particles['rs'] = particles.apply(lambda r: np.sqrt(r['x']**2+r['y']**2), axis = 1)
            particles.sort_values(by='rs',ascending=True, inplace=True)
            closest_particle = particles.iloc[0]
            specs_df.loc[img_counter,'tx']=closest_particle['cx']
            specs_df.loc[img_counter,'ty']=closest_particle['cy']
            specs_df.loc[img_counter,'tr']=closest_particle['radius'] if mode == 'radius' else closest_particle['rs']


    return(specs_df)

# Cell
def generate_mask(p: dict):
    """Given an image specification, this returns as mask showing particle centers"""
    m = np.zeros(int(p['size']))
    for P in p['particles']:
        r=radial_grid(int(p['size']),
                         (P['x'],P['y']),
                         p_r=P['radius'],
                         elip_d=P['ellip_direction'],
                         ellipticity=P['ellipticity'])
        r = (r<=P['radius']) * 1
        m = np.clip(m+r,0,1)

    return m

# Cell
def annotate_image(img, img_def, fs:int=12, clr='r', ax=None):
    """Add annotations to an image based on the parameters in `img_def`
    """
    if ax is None:
        ax=plt.gca();

    ax.imshow(img,interpolation='none',cmap='Greys_r')

    ax.grid(False);
    plt.axis('off')
    h=img_def['size']//2

    # text
    for i, p  in enumerate(img_def.keys()):
        if type(img_def[p]) is not list:
            ax.text(1.1,0.95-(i*0.07), f"{p} = {img_def[p]:0.3f}",transform=ax.transAxes, fontsize=fs)

    if (img_def['tx']==-999) or (img_def['tx']==-999):
        pass
    else:
        x=plt.Circle((img_def['tx'],img_def['ty']),img_def['tr'],lw=1,edgecolor=clr,facecolor='none')
        ax.add_artist(x)
        ax.scatter(x=img_def['tx'], y=img_def['ty'], s=1, c=clr)

    return None

# Cell
from pathlib import Path

def save_img(data: np.ndarray, path, i:int):
        """
        Saves image data as a png file in path
        """
        img = (data-data.min())/data.max()
        PILImage.fromarray(np.uint8(img * 255) , 'L').save(path/f'{i}.png',format='png')
        return None

def generate_images(specs: pd.DataFrame, path):
    """
    Takes a dataframe of image specifications, creates images and saves to pth
    """
    Path(path).mkdir(parents=True, exist_ok=True)

    for ir, row in df.iterrows():
        img = generate_image(row)
        save_img(img, path, ir)
