# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_fastai_adpater.ipynb (unless otherwise specified).

__all__ = ['MAELossFlat', 'npimg2tensor', 'MImageList', 'CustomSegmentationLabelList', 'CustomSegmentationItemList',
           'XYRItem', 'XYRList']

# Cell
import numpy as np
from PIL import Image
import pandas as pd
import matplotlib.pyplot as plt
from fastai.vision import *
from fastai.layers import FlattenedLoss
from fastai.torch_core import *
from fastai.layers import MSELossFlat
from fastai.data_block import ItemList, FloatList
from fastai.vision import Image, ImageList
from .simg import *

# Cell

def MAELossFlat(*args, axis:int=-1, floatify:bool=True, **kwargs):
    """Same as nn.L1Loss, but flattens input and target."""
    return FlattenedLoss(nn.L1Loss, *args, axis=axis, floatify=floatify, is_2d=False, **kwargs)

# Cell

def npimg2tensor(a):
    """Return the numpy array a, containing image data, as a torch tensor"""
    if a.ndim==2 : a = np.expand_dims(a,2)
    a = np.transpose(a, (1, 0, 2))
    a = np.transpose(a, (2, 1, 0))
    return torch.from_numpy(a.astype(np.float32))

class MImageList(ImageList):
    "`ItemList` suitable for 'image specs' to ThreePoints (x, y, r) Tasks."

    def __init__(self, items:Iterator, **kwargs)->'MImageList':
        super().__init__(range_of(items), **kwargs)
        # <-- the actual data, comes in through the **kwargs from_df class method
        # to ItemList where the data values are in inner_df, and items just becomes
        # a range of index values into that dataframe

    @classmethod
    def from_df(cls, df:pd.DataFrame, **kwargs)->'ItemList':
        df['img_data']=df.apply(lambda row: Image(npimg2tensor(generate_image(row))), axis=1)
        return cls(items=range(len(df)), inner_df=df.copy(), **kwargs)

    def get(self, i):
        # generate sythenthetic image from specification stored in items
        res=self.inner_df.iloc[i]['img_data']
        self.sizes[i] = res.size
        return res


class CustomSegmentationLabelList(MImageList):
    def open(self, i): return generate_mask(self.inner_df.iloc[i]) #after_open=self.after_open

class CustomSegmentationItemList(MImageList):
    "`ItemList` suitable for segmentation tasks."
    _label_cls,_square_show_res = CustomSegmentationLabelList,False



# Cell
class XYRItem(FloatItem):
    def show(self, ax:plt.Axes=None, figsize:Tuple=(3,3), title:Optional[str]=None, hide_axis:bool=True,
              cmap:str=None, y:Any=None, **kwargs):
        #xlim=ax.get_xlim(); ylim=ax.get_ylim()
        #hx=(xlim[1]-xlim[0])//2; hy=(ylim[0]-ylim[1])//2;
        ax.scatter(x=self.data[0],y=self.data[1],s=2,c=kwargs.get('marker_c','r'))
        ax.set_title(f'x={self.data[0]:.2f},y={self.data[1]:.2f},r={self.data[2]:.2f}')

class XYRList(ItemList):
    "`ItemList` suitable for storing the floats in items for regression. Will add a `log` if this flag is `True`."
    def __init__(self, items:Iterator, log:bool=False, classes:Collection=None, **kwargs):
        super().__init__(np.array(items, dtype=np.float32), **kwargs)
        self.log = log
        self.copy_new.append('log')
        self.c = self.items.shape[1] if len(self.items.shape) > 1 else 1
        self.loss_func = MAELossFlat()

    def get(self, i):
        o = super().get(i)
        return XYRItem(np.log(o) if self.log else o)

    def reconstruct(self,t): return XYRItem(t.numpy())
