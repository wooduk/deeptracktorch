# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_Measures.ipynb (unless otherwise specified).

__all__ = ['lsradialcenterfit', 'radialcenter']

# Cell
import matplotlib.pyplot as plt
import numpy as np
from numpy.matlib import repmat
from PIL import Image
from torch import Tensor

# Cell
def lsradialcenterfit(m, b, w):
#         % least squares solution to determine the radial symmetry center

#         % inputs m, b, w are defined on a grid
#         % w are the weights for each point
    wm2p1 = w/(m*m+1)
    sw  = sum(sum(wm2p1))
    smmw = sum(sum(m*m*wm2p1))
    smw  = sum(sum(m*wm2p1))
    smbw = sum(sum(m*b*wm2p1))
    sbw  = sum(sum(b*wm2p1))
    det = smw*smw - smmw*sw
    xc = (smbw*sw - smw*sbw)/det    #% relative to image center
    yc = (smbw*smw - smmw*sbw)/det #% relative to image center

    return xc, yc


# Cell
np.seterr(divide='ignore', invalid='ignore')

def radialcenter(I):
    """
    Calculates the center of a 2D intensity distribution.
    I: image data as torch tensor or 2d numpy array

    """
    if type(I) is Tensor:
        I=I.numpy().squeeze()
    else:
        pass
        # assume numpy

    nx, ny = I.shape
    L=nx
    xm=repmat(np.arange(-(L-1)/2.0+0.5,(L)/2.0-0.5), L-1,1)
    ym=repmat(np.arange(-(L-1)/2.0+0.5,(L)/2.0-0.5), L-1,1).T


    # Calculate derivatives along 45-degree shifted coordinates (u and v)
    # Note that y increases "downward" (increasing row number) -- we'll deal
    # with this when calculating "m" below.
    dIdu = I[0:L-1,1:L]-I[1:L,0:L-1]
    dIdv = I[0:L-1,0:L-1]-I[1:L,1:L]

    # Smoothing --
    from scipy.signal import convolve2d as conv2

    h = np.ones((3,3))/9;
    fdu = conv2(dIdu, h, 'same')
    fdv = conv2(dIdv, h, 'same')
    dImag2 = fdu*fdu + fdv*fdv

    # % Slope of the gradient .  Note that we need a 45 degree rotation of
    # % the u,v components to express the slope in the x-y coordinate system.
    # % The negative sign "flips" the array to account for y increasing
    # % "downward"

    # my code to avoid divide by zero and so NaN
    m = -(fdv + fdu) / (fdu - fdv)

    # % *Very* rarely, m might be NaN if (fdv + fdu) and (fdv - fdu) are both
    # % zero.  In this case, replace with the un-smoothed gradient.

    if np.isnan(m).any():
        unsmoothm = (dIdv + dIdu) / (dIdu-dIdv)
        m[np.isnan(m)]=unsmoothm[np.isnan(m)]

    # %If it's still NaN, replace with zero. (Very unlikely.)
    m[np.isnan(m)]=0


    # % Almost as rarely, an element of m can be infinite if the smoothed u and v
    # % derivatives are identical.  To avoid NaNs later, replace these with some
    # % large number -- 10x the largest non-infinite slope.  The sign of the
    # % infinity doesn't matter
    try:
        m[np.isinf(m)]=10*max(m[~np.isinf(m)]);
    except:
    #     % if this fails, it's because all the elements are infinite.  Replace
    #     % with the unsmoothed derivative.  There's probably a more elegant way
    #     % to do this.
         m = (dIdv + dIdu) / (dIdu-dIdv);

    #% Shorthand "b", which also happens to be the
    #% y intercept of the line of slope m that goes through each grid midpoint
    b = ym - m*xm

    #% Weighting: weight by square of gradient magnitude and inverse
    #% distance to gradient intensity centroid.
    sdI2 = dImag2.sum()
    xcentroid = sum(sum(dImag2*xm))/sdI2;
    ycentroid = sum(sum(dImag2*ym))/sdI2;
    w  = dImag2/np.sqrt((xm-xcentroid)*(xm-xcentroid)+(ym-ycentroid)*(ym-ycentroid))

    xc, yc = lsradialcenterfit(m, b, w)
    r = np.sqrt(xc**2 + yc**2)

    xr = xc + (L)/2.0;
    yr = yc + (L)/2.0;

    # % A rough measure of the particle width.
    # % Not at all connected to center determination, but may be useful for tracking applications;
    # % could eliminate for (very slightly) greater speed
    Isub = I - min(I.flatten())
    px,py = np.meshgrid(np.arange(0,nx),np.arange(0,ny));
    xoffset = px - xc;
    yoffset = py - yc;
    r2 = xoffset*xoffset + yoffset*yoffset;
    sigma = np.sqrt(sum(sum(Isub*r2))/sum(Isub.flatten()))/2 # % second moment is 2*Gaussian width


    return(xc,yc,r,sigma,xr,yr)
